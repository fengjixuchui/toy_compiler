# 编译原理——变量！



> 前言：我们要到编译原理比较难的地方了，我们开始在我们的语言 Lox 中，实现「变量」！



## 0X00 基本原理





这是我们实现的第三个语句，所以我们要更新程序的「上下文无关文法」



```python
program     → declaration* EOF ;

declaration → varDecl
                            | statement;

statement   → exprStmt
                           | printStmt;
```



之前的文法在这里：https://www.jianshu.com/p/9e4cff9f4594





然后我们再写出 varDecl 的文法：



```python
varDecl → "var" IDENTIFIER ( "=" expression )? ";" ;
```



同时我们能够操纵 identifier 了，所以我们要更新 primary 的文法：



```python
primary → "true" | "false" | "nil"
                     | NUMBER | STRING
                     | "(" expression ")"
                     | IDENTIFIER ;
```



至此，配合上代码，我们就能从 token 流中识别出，声明变量的操作。接下来我们需要学习「变量」及「作用域」的实现原理。





### 环境（**environment**）



![](https://upload-images.jianshu.io/upload_images/15548795-9cdb978c244b3086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



「标识符」和「标识符值」的「联系」需要保存在某个地方，我们把这个地方叫做「环境（environment）」



这个「环境」我们用 HashMap 实现，完成 String（标识符名字）到 Object 之间的映射



### 赋值（Assignment）



首先我们写出 Assignment 的语法：



```python
expression → assignment ;
assignment → IDENTIFIER "=" assignment
                            | equality ;
```



注意这里有一个复杂左值的问题：`a.b.c = 2`，这样的问题，在后面解决。



### 作用域（Slope）



```java
{
  var a = "first";
  print a; // "first".
}

{
  var a = "second";
  print a; // "second".
}
```



这里有两个作用域。



当然还有嵌套的作用域：

```java
{
  var a = "first";
    {
  		var a = "second";
  		print a; // "second".
	}
  print a; // "first".
}

```



为了识别这样的作用域，我们又得修改相关 `{}` 的「文法」



```python
statement → exprStmt
                          | printStmt
                          | block ;

block     → "{" declaration* "}" ;
```





有了块的概念以后，我们来说如何实现，作用域之间变量的隔离：



+ `当我们访问块（block）中的每个语句时，要在环境中追踪所有块中变量`
+ `当我们离开块（block）的时候，要删除那些在块中声明的变量`



这仅仅解决了，变量的隔离，还需要跟踪作用域链，查找变量。具体实现可以看后面的代码！



## 0X01 代码实现



